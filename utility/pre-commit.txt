#!/bin/bash

# Git pre-commit hook to prevent secrets and specific keywords from being committed
# This script should be placed in .git/hooks/pre-commit and made executable

# Configuration - Edit these variables to customize the hook
# ==============================================================

# Keywords to block (case-insensitive)
BLOCKED_KEYWORDS=(
    "password"
    "secret"
    "api_key"
    "apikey"
    "private_key"
    "auth_token"
    "access_token"
    "SECRET_KEY"
    "DATABASE_PASSWORD"
    "TODO_REMOVE_BEFORE_COMMIT"
    # Add your custom keywords here
)

# File extensions to check (leave empty to check all files)
FILE_EXTENSIONS=(
    "*.py"
    "*.js"
    "*.ts"
    "*.java"
    "*.go"
    "*.rb"
    "*.php"
    "*.cpp"
    "*.c"
    "*.h"
    "*.yml"
    "*.yaml"
    "*.json"
    "*.xml"
    "*.env"
    "*.config"
    "*.cfg"
    "*.ini"
    "*.txt"
    "*.md"
    # Add more extensions as needed
)

# Files to exclude from checking
EXCLUDED_FILES=(
    ".gitignore"
    "package-lock.json"
    "yarn.lock"
    "*.min.js"
    "*.min.css"
    # Add files you want to exclude
)

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Functions
# =========

print_header() {
    echo -e "${GREEN} Running pre-commit security check...${NC}"
}

print_error() {
    echo -e "${RED} $1${NC}"
}

print_warning() {
    echo -e "${YELLOW} $1${NC}"
}

print_success() {
    echo -e "${GREEN} $1${NC}"
}

is_file_excluded() {
    local file="$1"
    for excluded in "${EXCLUDED_FILES[@]}"; do
        if [[ "$file" == $excluded ]]; then
            return 0
        fi
    done
    return 1
}

should_check_file() {
    local file="$1"
    
    # Skip if file is excluded
    if is_file_excluded "$file"; then
        return 1
    fi
    
    # If no extensions specified, check all files
    if [ ${#FILE_EXTENSIONS[@]} -eq 0 ]; then
        return 0
    fi
    
    # Check if file matches any of the specified extensions
    for ext in "${FILE_EXTENSIONS[@]}"; do
        if [[ "$file" == $ext ]]; then
            return 0
        fi
    done
    
    return 1
}

check_for_secrets() {
    local violations_found=0
    local files_checked=0
    
    # Get list of staged files
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACM)
    
    if [ -z "$staged_files" ]; then
        print_warning "No staged files found"
        return 0
    fi
    
    while IFS= read -r file; do
        # Skip if file doesn't exist (might have been deleted)
        if [ ! -f "$file" ]; then
            continue
        fi
        
        # Skip if we shouldn't check this file
        if ! should_check_file "$file"; then
            continue
        fi
        
        files_checked=$((files_checked + 1))
        
        # Check for blocked keywords (case-insensitive)
        for keyword in "${BLOCKED_KEYWORDS[@]}"; do
            # Use git show to get the staged content
            local matches
            matches=$(git show ":$file" 2>/dev/null | grep -in "$keyword" || true)
            
            if [ -n "$matches" ]; then
                violations_found=1
                print_error "Found blocked keyword '$keyword' in file: $file"
                echo -e "${RED}Lines containing '$keyword':${NC}"
                echo "$matches" | while IFS= read -r match; do
                    echo -e "  ${RED}$match${NC}"
                done
                echo ""
            fi
        done
        
        # Check for common secret patterns
        local secret_patterns=(
            # API keys and tokens
            '[aA][pP][iI]_?[kK][eE][yY]\s*[=:]\s*["\x27][^"\x27\s]{20,}["\x27]'
            '[sS][eE][cC][rR][eE][tT]_?[kK][eE][yY]\s*[=:]\s*["\x27][^"\x27\s]{20,}["\x27]'
            '[aA][cC][cC][eE][sS][sS]_?[tT][oO][kK][eE][nN]\s*[=:]\s*["\x27][^"\x27\s]{20,}["\x27]'
            
            # Database connection strings
            'mysql://[^:\s]+:[^@\s]+@'
            'postgresql://[^:\s]+:[^@\s]+@'
            'mongodb://[^:\s]+:[^@\s]+@'
            
            # Private keys
            '-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----'
            '-----BEGIN\s+OPENSSH\s+PRIVATE\s+KEY-----'
            
            # AWS keys
            'AKIA[0-9A-Z]{16}'
            
            # Generic patterns for secrets
            '["\x27][A-Za-z0-9+/]{40,}["\x27]'  # Base64-like strings
            '["\x27][a-f0-9]{32,}["\x27]'       # Hex strings
        )
        
        for pattern in "${secret_patterns[@]}"; do
            local pattern_matches
            pattern_matches=$(git show ":$file" 2>/dev/null | grep -iE "$pattern" || true)
            
            if [ -n "$pattern_matches" ]; then
                violations_found=1
                print_error "Found potential secret pattern in file: $file"
                echo -e "${RED}Suspicious lines:${NC}"
                echo "$pattern_matches" | while IFS= read -r match; do
                    echo -e "  ${RED}$match${NC}"
                done
                echo ""
            fi
        done
        
    done <<< "$staged_files"
    
    if [ $files_checked -eq 0 ]; then
        print_warning "No files were checked (all files excluded or don't match extensions)"
        return 0
    fi
    
    if [ $violations_found -eq 1 ]; then
        print_error "Security violations found! Commit blocked."
        echo ""
        echo -e "${YELLOW}To bypass this check (not recommended):${NC}"
        echo -e "${YELLOW}  git commit --no-verify${NC}"
        echo ""
        echo -e "${YELLOW}To fix the issues:${NC}"
        echo -e "${YELLOW}  1. Remove the flagged content from your files${NC}"
        echo -e "${YELLOW}  2. Use environment variables or config files for secrets${NC}"
        echo -e "${YELLOW}  3. Add sensitive files to .gitignore${NC}"
        return 1
    else
        print_success "No security violations found in $files_checked files"
        return 0
    fi
}

# Main execution
# ================

print_header

# Run the security check
if ! check_for_secrets; then
    exit 1
fi

exit 0
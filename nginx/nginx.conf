# ============================================
# NGINX - Enterprise Microservice Gateway
# ============================================

user  nginx;                        # The user the nginx process will run as
worker_processes auto;
pid /var/run/nginx.pid;             # File path for the master process

events {                            # Configuration for event processing    
    worker_connections 4096;        # Max number of simultaneous connections
    multi_accept on;                # Accept all new connections simultaneously
}

http {
    # ------------------------
    # BASIC GLOBAL SETTINGS
    # ------------------------
    include       mime.types;          # File mapping to MIME types extension
    default_type  application/json;    # Set default MIME type for responses if not determined
    sendfile      on;                  # High-performance file transfers
    tcp_nopush    on;                  # Used with sendfile, sends HTTP headers and start of file in one packet
    tcp_nodelay   on;                  # Disables Nagle's for small packets to be sent immediately
    keepalive_timeout 65;
    client_max_body_size 10m;

    # ------------------------
    # LOGGING & OBSERVABILITY
    # ------------------------
    log_format json_combined escape=json                           # Custom log format named: json_combined
      '{'
        '"time_local":"$time_local",'
        '"remote_addr":"$remote_addr",'
        '"request":"$request",'
        '"status":$status,'
        '"body_bytes_sent":$body_bytes_sent,'
        '"request_time":$request_time,'
        '"upstream_addr":"$upstream_addr",'
        '"upstream_status":"$upstream_status",'
        '"upstream_response_time":"$upstream_response_time",'
        '"http_referer":"$http_referer",'
        '"http_user_agent":"$http_user_agent"'
      '}';

    access_log /var/log/nginx/access.log json_combined;            # Path for access_log file in json_combined format
    error_log  /var/log/nginx/error.log warn;                      # Path for error_log with level to WARN+

                                    # Expose Prometheus metrics (via nginx-prometheus-exporter or stub_status)
    server {                        # Server block for metrics endpoint
        listen 9113;
        location /metrics {
            stub_status;            # Enable basic NGINX status module for metrics
        }
    }

    # ------------------------
    # RATE LIMITING
    # ------------------------
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;      # Define shared memory zone 'api_limit'

    # ------------------------
    # UPSTREAMS
    # ------------------------
    upstream user_service {                      # Define named group of backend servers for user_service
        least_conn;
        server user-svc-1.internal:8080;
        server user-svc-2.internal:8080;
        keepalive 32;
    }

    upstream order_service {                     # Define named group of backend servers for order_service
        least_conn;
        server order-svc-1.internal:8080;
        server order-svc-2.internal:8080;
        keepalive 32;                            # Max 32 idle connections per worker
    }

    # ------------------------
    # MAIN API GATEWAY SERVER
    # ------------------------
    server {                                             # Main server block for API Gateway
        listen 443 ssl http2;
        server_name api.company.com;                     # Virtual server name(s) this server block responds to

        ssl_certificate /etc/nginx/ssl/fullchain.pem;    # Path to the SSL certificate file.
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;  # Path to the SSL private key file.
        ssl_protocols TLSv1.2 TLSv1.3;                   # SSL Protocols for security
        ssl_ciphers HIGH:!aNULL:!MD5;                    # Allowed ciphers

        # Security headers - HSTS forces secure connections for a long time
        add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";
        add_header X-Frame-Options DENY;                 # Prevents clickjacking
        add_header X-Content-Type-Options nosniff;       # Prevents browser MIME sniffing

        # Apply global rate limit
        limit_req zone=api_limit burst=20 nodelay;      # Allows 20 request bursts

        # ------------------------
        # JWT AUTHENTICATION (via Lua)
        # ------------------------
        lua_shared_dict jwt_keys 10m;                           # Shared memory zone for Lua variables

        access_by_lua_block {                                   # Executes Lua script before processing
            local jwt = require("resty.jwt")                    # Require resty jwt libraries
            local validators = require("resty.jwt-validators")

            local auth_header = ngx.var.http_Authorization
            if not auth_header then
                ngx.status = ngx.HTTP_UNAUTHORIZED
                ngx.say('{"error":"missing Authorization header"}')
                return ngx.exit(ngx.HTTP_UNAUTHORIZED)
            end

            local token = string.match(auth_header, "Bearer%s+(.+)")    # Extract JWT token from "Bearer "
            local jwt_obj = jwt:verify("your-secret-or-jwk", token, {   # Verify JWT sig and claims
                exp = validators.is_not_expired(),
                iat = validators.is_not_before()
            })

            if not jwt_obj.valid then
                ngx.status = ngx.HTTP_UNAUTHORIZED
                ngx.say('{"error":"invalid or expired token"}')
                return ngx.exit(ngx.HTTP_UNAUTHORIZED)                 # Return 401 Unatauthorized if token bad
            end
        }

        # ------------------------
        # ROUTING TO MICRO SERVICES
        # ------------------------
        location /api/v1/users/ {                                         # Block for requests matching this URI prefix
            proxy_pass http://user_service/;                              # Forward req to user_service upstream group
            proxy_set_header Host $host;                                  # Pass original Host header upstream
            proxy_set_header X-Real-IP $remote_addr;                      # Pass real IP of client
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # Append client IP to forwarded for list
            proxy_set_header X-Request-ID $request_id;
            proxy_http_version 1.1;
            proxy_set_header Connection "";                               # Clear connection headers for upstream
            proxy_read_timeout 60s;
        }

        location /api/v1/orders/ {
            proxy_pass http://order_service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Request-ID $request_id;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_read_timeout 60s;
        }

        # Default fallback
        location / {
            return 404 '{"error": "not found"}';             # Return 404 with a JSON body if not found
        }
    }
}
